// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model.proto

#ifndef PROTOBUF_model_2eproto__INCLUDED
#define PROTOBUF_model_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "external.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_model_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsInputInfoImpl();
void InitDefaultsInputInfo();
void InitDefaultsOutputInfoImpl();
void InitDefaultsOutputInfo();
void InitDefaultsModelMetaImpl();
void InitDefaultsModelMeta();
void InitDefaultsModelDefImpl();
void InitDefaultsModelDef();
inline void InitDefaults() {
  InitDefaultsInputInfo();
  InitDefaultsOutputInfo();
  InitDefaultsModelMeta();
  InitDefaultsModelDef();
}
}  // namespace protobuf_model_2eproto
namespace caffe2 {
class InputInfo;
class InputInfoDefaultTypeInternal;
extern InputInfoDefaultTypeInternal _InputInfo_default_instance_;
class ModelDef;
class ModelDefDefaultTypeInternal;
extern ModelDefDefaultTypeInternal _ModelDef_default_instance_;
class ModelMeta;
class ModelMetaDefaultTypeInternal;
extern ModelMetaDefaultTypeInternal _ModelMeta_default_instance_;
class OutputInfo;
class OutputInfoDefaultTypeInternal;
extern OutputInfoDefaultTypeInternal _OutputInfo_default_instance_;
}  // namespace caffe2
namespace caffe2 {

// ===================================================================

class InputInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.InputInfo) */ {
 public:
  InputInfo();
  virtual ~InputInfo();

  InputInfo(const InputInfo& from);

  inline InputInfo& operator=(const InputInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InputInfo(InputInfo&& from) noexcept
    : InputInfo() {
    *this = ::std::move(from);
  }

  inline InputInfo& operator=(InputInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputInfo* internal_default_instance() {
    return reinterpret_cast<const InputInfo*>(
               &_InputInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(InputInfo* other);
  friend void swap(InputInfo& a, InputInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InputInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  InputInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InputInfo& from);
  void MergeFrom(const InputInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InputInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 dims = 1;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 1;
  ::google::protobuf::uint32 dims(int index) const;
  void set_dims(int index, ::google::protobuf::uint32 value);
  void add_dims(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dims();

  // @@protoc_insertion_point(class_scope:caffe2.InputInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dims_;
  friend struct ::protobuf_model_2eproto::TableStruct;
  friend void ::protobuf_model_2eproto::InitDefaultsInputInfoImpl();
};
// -------------------------------------------------------------------

class OutputInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.OutputInfo) */ {
 public:
  OutputInfo();
  virtual ~OutputInfo();

  OutputInfo(const OutputInfo& from);

  inline OutputInfo& operator=(const OutputInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OutputInfo(OutputInfo&& from) noexcept
    : OutputInfo() {
    *this = ::std::move(from);
  }

  inline OutputInfo& operator=(OutputInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OutputInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutputInfo* internal_default_instance() {
    return reinterpret_cast<const OutputInfo*>(
               &_OutputInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(OutputInfo* other);
  friend void swap(OutputInfo& a, OutputInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OutputInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  OutputInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OutputInfo& from);
  void MergeFrom(const OutputInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OutputInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string labels = 1;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 1;
  const ::std::string& labels(int index) const;
  ::std::string* mutable_labels(int index);
  void set_labels(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_labels(int index, ::std::string&& value);
  #endif
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  ::std::string* add_labels();
  void add_labels(const ::std::string& value);
  #if LANG_CXX11
  void add_labels(::std::string&& value);
  #endif
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& labels() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_labels();

  // @@protoc_insertion_point(class_scope:caffe2.OutputInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> labels_;
  friend struct ::protobuf_model_2eproto::TableStruct;
  friend void ::protobuf_model_2eproto::InitDefaultsOutputInfoImpl();
};
// -------------------------------------------------------------------

class ModelMeta : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.ModelMeta) */ {
 public:
  ModelMeta();
  virtual ~ModelMeta();

  ModelMeta(const ModelMeta& from);

  inline ModelMeta& operator=(const ModelMeta& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelMeta(ModelMeta&& from) noexcept
    : ModelMeta() {
    *this = ::std::move(from);
  }

  inline ModelMeta& operator=(ModelMeta&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelMeta& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelMeta* internal_default_instance() {
    return reinterpret_cast<const ModelMeta*>(
               &_ModelMeta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ModelMeta* other);
  friend void swap(ModelMeta& a, ModelMeta& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelMeta* New() const PROTOBUF_FINAL { return New(NULL); }

  ModelMeta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModelMeta& from);
  void MergeFrom(const ModelMeta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModelMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .caffe2.InputInfo input = 1;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  const ::caffe2::InputInfo& input() const;
  ::caffe2::InputInfo* release_input();
  ::caffe2::InputInfo* mutable_input();
  void set_allocated_input(::caffe2::InputInfo* input);

  // optional .caffe2.OutputInfo output = 2;
  bool has_output() const;
  void clear_output();
  static const int kOutputFieldNumber = 2;
  const ::caffe2::OutputInfo& output() const;
  ::caffe2::OutputInfo* release_output();
  ::caffe2::OutputInfo* mutable_output();
  void set_allocated_output(::caffe2::OutputInfo* output);

  // @@protoc_insertion_point(class_scope:caffe2.ModelMeta)
 private:
  void set_has_input();
  void clear_has_input();
  void set_has_output();
  void clear_has_output();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::caffe2::InputInfo* input_;
  ::caffe2::OutputInfo* output_;
  friend struct ::protobuf_model_2eproto::TableStruct;
  friend void ::protobuf_model_2eproto::InitDefaultsModelMetaImpl();
};
// -------------------------------------------------------------------

class ModelDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:caffe2.ModelDef) */ {
 public:
  ModelDef();
  virtual ~ModelDef();

  ModelDef(const ModelDef& from);

  inline ModelDef& operator=(const ModelDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelDef(ModelDef&& from) noexcept
    : ModelDef() {
    *this = ::std::move(from);
  }

  inline ModelDef& operator=(ModelDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelDef* internal_default_instance() {
    return reinterpret_cast<const ModelDef*>(
               &_ModelDef_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ModelDef* other);
  friend void swap(ModelDef& a, ModelDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelDef* New() const PROTOBUF_FINAL { return New(NULL); }

  ModelDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModelDef& from);
  void MergeFrom(const ModelDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModelDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .caffe2.ModelMeta meta = 1;
  bool has_meta() const;
  void clear_meta();
  static const int kMetaFieldNumber = 1;
  const ::caffe2::ModelMeta& meta() const;
  ::caffe2::ModelMeta* release_meta();
  ::caffe2::ModelMeta* mutable_meta();
  void set_allocated_meta(::caffe2::ModelMeta* meta);

  // optional .caffe2.NetDef init = 2;
  bool has_init() const;
  void clear_init();
  static const int kInitFieldNumber = 2;
  const ::caffe2::NetDef& init() const;
  ::caffe2::NetDef* release_init();
  ::caffe2::NetDef* mutable_init();
  void set_allocated_init(::caffe2::NetDef* init);

  // optional .caffe2.NetDef predict = 3;
  bool has_predict() const;
  void clear_predict();
  static const int kPredictFieldNumber = 3;
  const ::caffe2::NetDef& predict() const;
  ::caffe2::NetDef* release_predict();
  ::caffe2::NetDef* mutable_predict();
  void set_allocated_predict(::caffe2::NetDef* predict);

  // @@protoc_insertion_point(class_scope:caffe2.ModelDef)
 private:
  void set_has_meta();
  void clear_has_meta();
  void set_has_init();
  void clear_has_init();
  void set_has_predict();
  void clear_has_predict();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::caffe2::ModelMeta* meta_;
  ::caffe2::NetDef* init_;
  ::caffe2::NetDef* predict_;
  friend struct ::protobuf_model_2eproto::TableStruct;
  friend void ::protobuf_model_2eproto::InitDefaultsModelDefImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InputInfo

// repeated uint32 dims = 1;
inline int InputInfo::dims_size() const {
  return dims_.size();
}
inline void InputInfo::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::uint32 InputInfo::dims(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.InputInfo.dims)
  return dims_.Get(index);
}
inline void InputInfo::set_dims(int index, ::google::protobuf::uint32 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.InputInfo.dims)
}
inline void InputInfo::add_dims(::google::protobuf::uint32 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:caffe2.InputInfo.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
InputInfo::dims() const {
  // @@protoc_insertion_point(field_list:caffe2.InputInfo.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
InputInfo::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.InputInfo.dims)
  return &dims_;
}

// -------------------------------------------------------------------

// OutputInfo

// repeated string labels = 1;
inline int OutputInfo::labels_size() const {
  return labels_.size();
}
inline void OutputInfo::clear_labels() {
  labels_.Clear();
}
inline const ::std::string& OutputInfo::labels(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.OutputInfo.labels)
  return labels_.Get(index);
}
inline ::std::string* OutputInfo::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.OutputInfo.labels)
  return labels_.Mutable(index);
}
inline void OutputInfo::set_labels(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.OutputInfo.labels)
  labels_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OutputInfo::set_labels(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.OutputInfo.labels)
  labels_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OutputInfo::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.OutputInfo.labels)
}
inline void OutputInfo::set_labels(int index, const char* value, size_t size) {
  labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.OutputInfo.labels)
}
inline ::std::string* OutputInfo::add_labels() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.OutputInfo.labels)
  return labels_.Add();
}
inline void OutputInfo::add_labels(const ::std::string& value) {
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.OutputInfo.labels)
}
#if LANG_CXX11
inline void OutputInfo::add_labels(::std::string&& value) {
  labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.OutputInfo.labels)
}
#endif
inline void OutputInfo::add_labels(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.OutputInfo.labels)
}
inline void OutputInfo::add_labels(const char* value, size_t size) {
  labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.OutputInfo.labels)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OutputInfo::labels() const {
  // @@protoc_insertion_point(field_list:caffe2.OutputInfo.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OutputInfo::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.OutputInfo.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// ModelMeta

// optional .caffe2.InputInfo input = 1;
inline bool ModelMeta::has_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelMeta::set_has_input() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelMeta::clear_has_input() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelMeta::clear_input() {
  if (input_ != NULL) input_->Clear();
  clear_has_input();
}
inline const ::caffe2::InputInfo& ModelMeta::input() const {
  const ::caffe2::InputInfo* p = input_;
  // @@protoc_insertion_point(field_get:caffe2.ModelMeta.input)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::InputInfo*>(
      &::caffe2::_InputInfo_default_instance_);
}
inline ::caffe2::InputInfo* ModelMeta::release_input() {
  // @@protoc_insertion_point(field_release:caffe2.ModelMeta.input)
  clear_has_input();
  ::caffe2::InputInfo* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::caffe2::InputInfo* ModelMeta::mutable_input() {
  set_has_input();
  if (input_ == NULL) {
    input_ = new ::caffe2::InputInfo;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.ModelMeta.input)
  return input_;
}
inline void ModelMeta::set_allocated_input(::caffe2::InputInfo* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    set_has_input();
  } else {
    clear_has_input();
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelMeta.input)
}

// optional .caffe2.OutputInfo output = 2;
inline bool ModelMeta::has_output() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelMeta::set_has_output() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelMeta::clear_has_output() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelMeta::clear_output() {
  if (output_ != NULL) output_->Clear();
  clear_has_output();
}
inline const ::caffe2::OutputInfo& ModelMeta::output() const {
  const ::caffe2::OutputInfo* p = output_;
  // @@protoc_insertion_point(field_get:caffe2.ModelMeta.output)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::OutputInfo*>(
      &::caffe2::_OutputInfo_default_instance_);
}
inline ::caffe2::OutputInfo* ModelMeta::release_output() {
  // @@protoc_insertion_point(field_release:caffe2.ModelMeta.output)
  clear_has_output();
  ::caffe2::OutputInfo* temp = output_;
  output_ = NULL;
  return temp;
}
inline ::caffe2::OutputInfo* ModelMeta::mutable_output() {
  set_has_output();
  if (output_ == NULL) {
    output_ = new ::caffe2::OutputInfo;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.ModelMeta.output)
  return output_;
}
inline void ModelMeta::set_allocated_output(::caffe2::OutputInfo* output) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete output_;
  }
  if (output) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      output = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }
    set_has_output();
  } else {
    clear_has_output();
  }
  output_ = output;
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelMeta.output)
}

// -------------------------------------------------------------------

// ModelDef

// optional .caffe2.ModelMeta meta = 1;
inline bool ModelDef::has_meta() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelDef::set_has_meta() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelDef::clear_has_meta() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelDef::clear_meta() {
  if (meta_ != NULL) meta_->Clear();
  clear_has_meta();
}
inline const ::caffe2::ModelMeta& ModelDef::meta() const {
  const ::caffe2::ModelMeta* p = meta_;
  // @@protoc_insertion_point(field_get:caffe2.ModelDef.meta)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::ModelMeta*>(
      &::caffe2::_ModelMeta_default_instance_);
}
inline ::caffe2::ModelMeta* ModelDef::release_meta() {
  // @@protoc_insertion_point(field_release:caffe2.ModelDef.meta)
  clear_has_meta();
  ::caffe2::ModelMeta* temp = meta_;
  meta_ = NULL;
  return temp;
}
inline ::caffe2::ModelMeta* ModelDef::mutable_meta() {
  set_has_meta();
  if (meta_ == NULL) {
    meta_ = new ::caffe2::ModelMeta;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.ModelDef.meta)
  return meta_;
}
inline void ModelDef::set_allocated_meta(::caffe2::ModelMeta* meta) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete meta_;
  }
  if (meta) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      meta = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    set_has_meta();
  } else {
    clear_has_meta();
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelDef.meta)
}

// optional .caffe2.NetDef init = 2;
inline bool ModelDef::has_init() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelDef::set_has_init() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelDef::clear_has_init() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::caffe2::NetDef& ModelDef::init() const {
  const ::caffe2::NetDef* p = init_;
  // @@protoc_insertion_point(field_get:caffe2.ModelDef.init)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::NetDef*>(
      &::caffe2::_NetDef_default_instance_);
}
inline ::caffe2::NetDef* ModelDef::release_init() {
  // @@protoc_insertion_point(field_release:caffe2.ModelDef.init)
  clear_has_init();
  ::caffe2::NetDef* temp = init_;
  init_ = NULL;
  return temp;
}
inline ::caffe2::NetDef* ModelDef::mutable_init() {
  set_has_init();
  if (init_ == NULL) {
    init_ = new ::caffe2::NetDef;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.ModelDef.init)
  return init_;
}
inline void ModelDef::set_allocated_init(::caffe2::NetDef* init) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(init_);
  }
  if (init) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      init = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, init, submessage_arena);
    }
    set_has_init();
  } else {
    clear_has_init();
  }
  init_ = init;
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelDef.init)
}

// optional .caffe2.NetDef predict = 3;
inline bool ModelDef::has_predict() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelDef::set_has_predict() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelDef::clear_has_predict() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::caffe2::NetDef& ModelDef::predict() const {
  const ::caffe2::NetDef* p = predict_;
  // @@protoc_insertion_point(field_get:caffe2.ModelDef.predict)
  return p != NULL ? *p : *reinterpret_cast<const ::caffe2::NetDef*>(
      &::caffe2::_NetDef_default_instance_);
}
inline ::caffe2::NetDef* ModelDef::release_predict() {
  // @@protoc_insertion_point(field_release:caffe2.ModelDef.predict)
  clear_has_predict();
  ::caffe2::NetDef* temp = predict_;
  predict_ = NULL;
  return temp;
}
inline ::caffe2::NetDef* ModelDef::mutable_predict() {
  set_has_predict();
  if (predict_ == NULL) {
    predict_ = new ::caffe2::NetDef;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.ModelDef.predict)
  return predict_;
}
inline void ModelDef::set_allocated_predict(::caffe2::NetDef* predict) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(predict_);
  }
  if (predict) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      predict = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, predict, submessage_arena);
    }
    set_has_predict();
  } else {
    clear_has_predict();
  }
  predict_ = predict;
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelDef.predict)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace caffe2

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_model_2eproto__INCLUDED
